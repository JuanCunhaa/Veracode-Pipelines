name: Veracode Workflow (Builds + Pipeline Scan + SAST)

on:
  workflow_call:
    inputs:
      build_artifact_name:
        type: string
        required: false
        default: 'build-artifact'
        description: 'Name of the build artifact uploaded in the build step'
      build_artifact_path:
        type: string
        required: false
        default: 'build'
        description: 'The file path where the build artifact will be downloaded/extracted'
      build_artifact_exclude_patterns:
        type: string
        required: false
        default: ''
        description: 'Comma separated exclude patterns for files that dont need to be scanned (ex: test code)'
      project_name:
        type: string
        required: false
        default: ''
        description: 'Project name. If left empty, the repository name will be used'
    secrets:
      SCAN_API_TOKEN:
        description: 'Veracode SCA API Token'
        required: true
      SCAN_API_ID:
        description: 'Veracode API ID'
        required: true
      SCAN_API_KEY:
        description: 'Veracode API KEY'
        required: true

permissions:
  contents: read
  actions: read

jobs:

  autopackager:
    name: Veracode Auto Packager
    runs-on: ubuntu-latest
    steps:
      - name: üîΩ Download build artifact (original)
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.build_artifact_name }}
          path: ${{ inputs.build_artifact_path }}

      - name: üîé Pr√©-checagem de bin√°rios (.dll/.pdb/.jar/.war) e empacotamento
        id: precheck_binaries
        shell: bash
        run: |
          set -euo pipefail

          WORKDIR="${{ inputs.build_artifact_path }}"
          echo "Varredura recursiva em: $WORKDIR"
          
          if [[ -z "${WORKDIR:-}" ]]; then
            echo "ERRO: WORKDIR est√° vazio."; exit 1
          fi
          if [[ ! -d "$WORKDIR" ]]; then
            echo "ERRO: WORKDIR n√£o existe: $WORKDIR"; exit 1
          fi
          WORKDIR_ABS="$(cd "$WORKDIR" && pwd -P)"
          if [[ -z "$WORKDIR_ABS" || "$WORKDIR_ABS" == "/" ]]; then
            echo "ERRO: WORKDIR resolve para raiz; abortando."; exit 1
          fi

          if [[ -n "${GITHUB_WORKSPACE:-}" ]]; then
            WS_ABS="$(cd "$GITHUB_WORKSPACE" && pwd -P)"
            case "$WORKDIR_ABS" in
              "$WS_ABS"/*|"$WS_ABS") : ;; # ok
              *) echo "ERRO: WORKDIR n√£o est√° dentro de GITHUB_WORKSPACE."; exit 1 ;;
            esac
          fi

          sudo apt-get update -y
          sudo apt-get install -y zip unzip

          OUT_DIR="${GITHUB_WORKSPACE}/veracode-out"
          mkdir -p "$OUT_DIR"

          BUNDLE_DIR="$(mktemp -d)"
          trap 'rm -rf "$BUNDLE_DIR"' EXIT

          FOUND_ANY=false

          while IFS= read -r -d '' f; do
            FOUND_ANY=true
            base="$(basename "$f")"
            # Trata colis√£o por basename
            if [[ -e "$BUNDLE_DIR/$base" ]]; then
              i=1
              while [[ -e "$BUNDLE_DIR/${i}_$base" ]]; do i=$((i+1)); done
              cp -f -- "$f" "$BUNDLE_DIR/${i}_$base"
              echo "Adicionado (colis√£o): ${i}_$base"
            else
              cp -f -- "$f" "$BUNDLE_DIR/$base"
              echo "Adicionado: $base"
            fi
          done < <(
            find "$WORKDIR_ABS" \
              \( -type d \( -name node_modules -o -name .git -o -name .svn -o -name .hg -o -name vendor -o -name .m2 -o -name .gradle -o -name .ivy2 -o -name .pnpm-store -o -name .yarn -o -name .cache -o -name .venv -o -name venv -o -name .terraform \) -prune \) -o \
              \( -type f \( -iname '*.dll' -o -iname '*.pdb' -o -iname '*.jar' -o -iname '*.war' \) -print0 \)
          )

          if $FOUND_ANY; then
            echo "Arquivos compilados detectados; gerando pacote..."
            (cd "$BUNDLE_DIR" && zip -qr "$OUT_DIR/analysisPack.zip" .)

            shopt -s dotglob nullglob
            CONTENTS=("$WORKDIR_ABS"/*)
            if ((${#CONTENTS[@]})); then
              rm -rf -- "${CONTENTS[@]}"
            fi
            shopt -u dotglob nullglob

            cp -f -- "$OUT_DIR/analysisPack.zip" "$WORKDIR_ABS/analysisPack.zip"

            echo "skip_packager=true" >> "$GITHUB_OUTPUT"
            echo "Fluxo alternativo - Arquivos compilados detectados."
          else
            echo "Fluxo original - Nenhum arquivo compilado detectado."
            echo "skip_packager=false" >> "$GITHUB_OUTPUT"
          fi


      - name: ‚¨áÔ∏è Instalar Veracode CLI
        if: steps.precheck_binaries.outputs.skip_packager == 'false'
        run: |
          set -euo pipefail
          curl -fsS https://tools.veracode.com/veracode-cli/install | sh
          ./veracode version

      - name: üì¶ Executar Auto Packager (verbose) no artifact baixado
        if: steps.precheck_binaries.outputs.skip_packager == 'false'
        run: |
          set -euo pipefail
          SRC_DIR="${{ inputs.build_artifact_path }}"
          out_dir="veracode-out"
          mkdir -p "$out_dir"
          ./veracode package --source "$SRC_DIR" --output "$out_dir" --trust --verbose
          echo "‚úÖ Pacotes gerados:"
          ls -lh "$out_dir"

      - name: üß© Compilar pacotes em analysisPack.zip
        if: steps.precheck_binaries.outputs.skip_packager == 'false'
        shell: bash
        run: |
          set -euo pipefail

          ARTIFACT_DIR="${GITHUB_WORKSPACE}/veracode-out"

          sudo apt-get update -y
          sudo apt-get install -y zip unzip

          cd "${ARTIFACT_DIR}"

          mkdir -p merged

          echo "Procurando arquivos .zip em ${ARTIFACT_DIR}"
          shopt -s nullglob
          zips=( *.zip )
          if [ ${#zips[@]} -gt 0 ]; then
            for zipf in "${zips[@]}"; do
              echo "Extraindo $zipf para merged/"
              unzip -oq "$zipf" -d merged/
            done
          else
            echo "Nenhum arquivo .zip encontrado (ok, seguiremos apenas com as pastas/arquivos gerados)."
          fi

          for item in *; do
            if [[ "$item" != "merged" && "$item" != *.zip ]]; then
              echo "Movendo $item para merged/"
              mv "$item" merged/
            fi
          done

          echo "Compactando tudo em analysisPack.zip"
          rm -f /tmp/analysisPack.zip
          (cd merged && zip -qr /tmp/analysisPack.zip .)

          echo "Limpando ${ARTIFACT_DIR}"
          rm -rf ./*

          mv /tmp/analysisPack.zip ./analysisPack.zip

          echo "Novo pacote pronto: ${ARTIFACT_DIR}/analysisPack.zip"
          ls -lh "${ARTIFACT_DIR}/analysisPack.zip"

      - name: üì§ Upload analysisPack.zip
        uses: actions/upload-artifact@v4
        with:
          name: analysisPack
          path: veracode-out/analysisPack.zip

  sca:
    name: Veracode SCA
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Check for SCA Secrets
        id: check_sca_secrets
        run: |
          if [[ -n "${{ secrets.SCAN_API_TOKEN }}" ]]; then
            echo "run_scan=true" >> $GITHUB_OUTPUT
          else
            echo "run_scan=false" >> $GITHUB_OUTPUT
            echo "::warning::SCA scan skipped because SCAN_API_TOKEN secret is not set."
          fi

      - name: Run Veracode SCA
        if: steps.check_sca_secrets.outputs.run_scan == 'true'
        env:
          SRCCLR_API_TOKEN: ${{ secrets.SCAN_API_TOKEN }}
        run: |
          echo "üîç Starting Veracode SCA..."
          curl -sSL 'https://download.sourceclear.com/ci.sh' | bash -s -- scan

  pipeline_scan:
    name: Pipeline Scan
    runs-on: ubuntu-latest
    needs: [sca, autopackager]
    if: always()
    steps:
      - name: Download analysisPack artifact
        uses: actions/download-artifact@v4
        with:
          name: analysisPack
          path: ${{ inputs.build_artifact_path }}

      - name: Preparar arquivo para o scan (evitar zip duplo)
        id: prepare_scan_file
        env:
          EXCLUDE_PATTERNS: ${{ inputs.build_artifact_exclude_patterns }}
        run: |
          set -euo pipefail
          WORKDIR="${{ inputs.build_artifact_path }}"
          echo "Conte√∫do do path:"
          ls -lah "$WORKDIR" || true

          if [ -f "$WORKDIR/analysisPack.zip" ]; then
            echo "file=$WORKDIR/analysisPack.zip" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ -n "${EXCLUDE_PATTERNS}" ]]; then
            IFS=',' read -ra EXCLUDE_PATTERNS_ARRAY <<< "${EXCLUDE_PATTERNS}"
            (cd "$(dirname "$WORKDIR")" && zip -r "${WORKDIR}.zip" "$(basename "$WORKDIR")" -x "${EXCLUDE_PATTERNS_ARRAY[@]}")
          else
            (cd "$(dirname "$WORKDIR")" && zip -r "${WORKDIR}.zip" "$(basename "$WORKDIR")")
          fi
          echo "file=${WORKDIR}.zip" >> $GITHUB_OUTPUT

      - name: Check for SAST/Pipeline Secrets
        id: check_sast_secrets
        run: |
          if [[ -n "${{ secrets.SCAN_API_ID }}" && -n "${{ secrets.SCAN_API_KEY }}" ]]; then
            echo "run_scan=true" >> $GITHUB_OUTPUT
          else
            echo "run_scan=false" >> $GITHUB_OUTPUT
            echo "::warning::Pipeline scan skipped because SCAN_API_ID or SCAN_API_KEY secrets are not set."
          fi

      - name: Run Veracode Pipeline Scan
        if: steps.check_sast_secrets.outputs.run_scan == 'true'
        uses: veracode/Veracode-pipeline-scan-action@v1.0.18
        with:
          vid: ${{ secrets.SCAN_API_ID }}
          vkey: ${{ secrets.SCAN_API_KEY }}
          file: ${{ steps.prepare_scan_file.outputs.file }}
          fail_build: false

  sast:
    name: Veracode Upload & SAST
    runs-on: ubuntu-latest
    needs: [pipeline_scan]
    if: always()
    outputs:
      app_id: ${{ steps.get_ids.outputs.app_id }}
      build_id: ${{ steps.get_ids.outputs.build_id }}
    steps:
      - name: Download analysisPack artifact
      - uses: actions/download-artifact@v4
        with:
          name: analysisPack
          path: ${{ inputs.build_artifact_path }}

      - name: Preparar arquivo para o SAST (evitar zip duplo)
        id: prepare_sast_file
        env:
          EXCLUDE_PATTERNS: ${{ inputs.build_artifact_exclude_patterns }}
        run: |
          set -euo pipefail
          WORKDIR="${{ inputs.build_artifact_path }}"
          echo "Conte√∫do do path:"
          ls -lah "$WORKDIR" || true

          if [ -f "$WORKDIR/analysisPack.zip" ]; then
            echo "file=$WORKDIR/analysisPack.zip" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ -n "${EXCLUDE_PATTERNS}" ]]; then
            IFS=',' read -ra EXCLUDE_PATTERNS_ARRAY <<< "${EXCLUDE_PATTERNS}"
            (cd "$(dirname "$WORKDIR")" && zip -r "${WORKDIR}.zip" "$(basename "$WORKDIR")" -x "${EXCLUDE_PATTERNS_ARRAY[@]}")
          else
            (cd "$(dirname "$WORKDIR")" && zip -r "${WORKDIR}.zip" "$(basename "$WORKDIR")")
          fi
          echo "file=${WORKDIR}.zip" >> $GITHUB_OUTPUT

      - name: Check for SAST/Pipeline Secrets
        id: check_sast_secrets
        run: |
          if [[ -n "${{ secrets.SCAN_API_ID }}" && -n "${{ secrets.SCAN_API_KEY }}" ]]; then
            echo "run_scan=true" >> $GITHUB_OUTPUT
          else
            echo "run_scan=false" >> $GITHUB_OUTPUT
            echo "::warning::SAST scan skipped because SCAN_API_ID or SCAN_API_KEY secrets are not set."
          fi

      - name: Run Veracode Upload & SAST
        if: steps.check_sast_secrets.outputs.run_scan == 'true'
        uses: veracode/veracode-uploadandscan-action@0.2.8
        env:
          PROJECT_NAME: ${{ inputs.project_name != '' && inputs.project_name || github.repository }}
        with:
          vid: ${{ secrets.SCAN_API_ID }}
          vkey: ${{ secrets.SCAN_API_KEY }}
          appname: "GitHub - ${{ env.PROJECT_NAME }}"
          createprofile: true
          filepath: ${{ steps.prepare_sast_file.outputs.file }}
          version: "${{ github.run_id }}-${{ github.run_attempt }}"
          deleteincompletescan: 2

      # üîé XML API para pegar APPID/BUILDID de forma robusta
      - name: Get AppID/BuildID via XML API (recomendado)
        id: get_ids
        if: steps.check_sast_secrets.outputs.run_scan == 'true'
        env:
          PROJECT_NAME: ${{ inputs.project_name != '' && inputs.project_name || github.repository }}
          VERSION_TAG: "${{ github.run_id }}-${{ github.run_attempt }}"
        run: |
          set -euo pipefail
          sudo apt-get update -y && sudo apt-get install -y libxml2-utils curl

          APP_NAME="GitHub - ${PROJECT_NAME}"
          echo "Procurando app: ${APP_NAME}"

          # 1) APP ID
          APP_XML="$(curl -s -u "${{ secrets.SCAN_API_ID }}:${{ secrets.SCAN_API_KEY }}" \
            "https://analysiscenter.veracode.com/api/5.0/getapplist.do")"

          APP_ID="$(echo "$APP_XML" | xmllint --xpath "string(//application[@app_name='${APP_NAME}']/@app_id)" - 2>/dev/null || true)"

          if [[ -z "$APP_ID" ]]; then
            echo "::error::app_id n√£o encontrado para '${APP_NAME}'"
            exit 1
          fi

          # 2) BUILD ID pelo version usado no uploadandscan
          BUILD_XML="$(curl -s -u "${{ secrets.SCAN_API_ID }}:${{ secrets.SCAN_API_KEY }}" \
            "https://analysiscenter.veracode.com/api/5.0/getbuildlist.do?app_id=${APP_ID}")"

          BUILD_ID="$(echo "$BUILD_XML" | xmllint --xpath "string(//build[@version='${VERSION_TAG}']/@build_id)" - 2>/dev/null || true)"

          echo "app_id=${APP_ID}"   >> "$GITHUB_OUTPUT"
          echo "build_id=${BUILD_ID}" >> "$GITHUB_OUTPUT"

          echo "üìå AppID: ${APP_ID}"
          echo "üìå BuildID: ${BUILD_ID:-<n√£o encontrado p/ essa vers√£o>}"
